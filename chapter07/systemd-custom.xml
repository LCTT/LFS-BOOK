<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE sect1 PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
  "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [
  <!ENTITY % general-entities SYSTEM "../general.ent">
  %general-entities;
]>

<sect1 id="ch-scripts-systemd-custom" revision="systemd">
  <?dbhtml filename="systemd-custom.html"?>

  <title>Systemd 的用法与配置</title>

  <indexterm zone="ch-scripts-systemd-custom">
    <primary sortas="e-Systemd">Systemd 配置</primary>
  </indexterm>

  <sect2>
    <title>基础配置</title>

    <para><filename>/etc/systemd/system.conf</filename> 文件包含了大量的 systemd 控制命令。
    假如未作任何的更改，文件中的所有行应该都是注释掉的，这代表了 systemd 正使用默认的运行方式。
    这个文件中可以设置日志级别，可以修改日志的基本设置。所有设置项都可以在 man 手册的 <filename>systemd-system.conf(5)</filename> 中查看。</para>

  </sect2>

  <sect2>
    <title>禁用启动时清屏</title>

    <para>默认情况下，systemd 将会在系统启动快要结束的时候清屏。如不需要，使用以下操作禁用：</para>

<screen role="nodump"><userinput>mkdir -pv /etc/systemd/system/getty@tty1.service.d

cat &gt; /etc/systemd/system/getty@tty1.service.d/noclear.conf &lt;&lt; EOF
<literal>[Service]
TTYVTDisallocate=no</literal>
EOF</userinput></screen>

    <para>拥有 root 权限的账户总是可以通过 <userinput>journalctl -b</userinput> 查看启动信息。</para>

  </sect2>

  <sect2>
    <title>禁止 /tmp 使用 tmpfs</title>

    <para>默认情况下，<filename class="directory">/tmp</filename> 使用 tmpfs 文件系统。如不需要，使用以下操作禁用：</para>

<screen role="nodump"><userinput>ln -sfv /dev/null /etc/systemd/system/tmp.mount</userinput></screen>

    <para>如果已经为 <filename class="directory">/tmp</filename> 在 <filename>/etc/fstab</filename> 中指定了专门的分区，
    那么此操作是多余的。</para>

  </sect2>

  <sect2>
    <title>配置自动创建和删除文件</title>

    <para>有这样几个服务可以建立或删除文件/目录：</para>

    <itemizedlist>
      <listitem><para>systemd-tmpfiles-clean.service</para></listitem>
      <listitem><para>systemd-tmpfiles-setup-dev.service</para></listitem>
      <listitem><para>systemd-tmpfiles-setup.service</para></listitem>
    </itemizedlist>

    <para>系统配置文件在 <filename>/usr/lib/tmpfiles.d/*.conf</filename> 中。
      本地配置文件在 <filename class="directory">/etc/tmpfiles.d</filename> 中。
      <filename class="directory">/etc/tmpfiles.d</filename>中的文件会覆盖 <filename class="directory">/usr/lib/tmpfiles.d</filename> 中相同名称的文件。
      （译者注：首先读取系统范围配置文件，再读取用户范围配置文件，用户范围配置文件会覆盖系统范围配置文件的相同部分。）可以在 man 手册的 <filename>tmpfiles.d(5)</filename> 中获取文件格式详情。</para>

  </sect2>

  <sect2>
    <title>覆盖默认服务的行为</title>

    <para>The parameter of a unit can be overriden by creating a directory
    and a configuration file in <filename
    class="directory">/etc/systemd/system</filename>. For example:</para>

<screen role="nodump"><userinput>mkdir -pv /etc/systemd/system/foobar.service.d

cat > /etc/systemd/system/foobar.service.d/foobar.conf &lt;&lt; EOF
<literal>[Service]
Restart=always
RestartSec=30</literal>
EOF</userinput></screen>

     <para>可以在 man 手册的 <filename>systemd.unit(5)</filename> 中查询更多信息。创建好文件之后，请运行 <userinput>systemctl daemon-reload</userinput> 和 <userinput>systemctl restart foobar</userinput> 激活所做更改。</para>

  </sect2>

  <sect2>
    <title>调试启动顺序</title>

    <para>相较于 SysVinit 或 BSD 风格的初始化使用的是简单的 shell 脚本，而 systemd 对于不同类型的启动文件（或单元）使用的是统一的格式。<command>systemctl</command> 命令可用于用于，启用，禁用，控制状态，和获取单元文件的状态。以下是一些常用命令的示例：</para>

    <itemizedlist>
       <listitem>
         <para><command>systemctl list-units -t <replaceable>&lt;service&gt;</replaceable> [--all]</command>：列出加载的服务类型的单元文件。</para>
       </listitem>
       <listitem>
         <para><command>systemctl list-units -t <replaceable>&lt;target&gt;</replaceable> [--all]</command>：列出加载的目标类型的单元文件。</para>
       </listitem>
       <listitem>
         <para><command>systemctl show -p Wants <replaceable>&lt;multi-user.target&gt;</replaceable></command>：显示所有依赖多用户的目标。目标是与 SysVinit 运行级不同的特殊单元文件。</para>
       </listitem>
       <listitem>
         <para><command>systemctl status <replaceable>&lt;servicename.service&gt;</replaceable></command>：显示服务名称服务的状态。扩展名 .service 在没有同名单元文件，例如 .socket（创建监听套接字功能与 inetd/xinetd 相似的）文件，的情况下可以省略。</para>
       </listitem>
    </itemizedlist>

  </sect2>

  <sect2>
    <title>使用 systemd 日志</title>

    <para>systemd 启动的系统上的日志记录（默认）由 systemd-journald 处理的，而不是传统的 unix syslog 守护程序。如果需要，你也可以添加 syslog 的守护进程与之并行运作。systemd-journald 程序使用二进制形式存储日志条目而非纯文本的日志文件。为了帮助解析文件，提供了 <command>journalctl</command> 命令。以下是一些常用命令的示例：</para>

    <itemizedlist>
       <listitem>
         <para><command>journalctl -r</command>：按时间逆序现实所有的内容。</para>
       </listitem>
       <listitem>
         <para><command>journalctl -u <replaceable>UNIT</replaceable></command>：显示与指定 UNIT 相关的日志条目。</para>
       </listitem>
       <listitem>
         <para><command>journalctl -b[=ID] -r</command>：按时间逆序显示自上次成功启动（或启动 ID）的日志条目。</para>
       </listitem>
       <listitem>
         <para><command>journalctl -f</command>：提供类似与 tail -f (follow) 类似的功能。</para>
       </listitem>
    </itemizedlist>

  </sect2>

  <sect2>
    <title>长时间运行进程</title>

    <para>自 systemd-230 开始，用户的所有进程都会随着用户会话的结束而被杀死，即使你用了 nohup，或进程使用了 <function>daemon()</function> 或是 <function>setsid()</function>。这是为了是让原先宽松的环境变得更为严格而故意为之的。如果你依赖长时间运行的程序（例如，<command>screen</command> 或是 <command>tmux</command>），需要在你结束用户会话后保持运作。有三个方法能让进程保持在用户会话结束后仍然逗留。</para>

    <itemizedlist>
      <listitem>
        <para>
          <emphasis>仅为需要的用户启用进程逗留</emphasis>：正常用户有权使用命令 <command>loginctl enable-linger</command> 来为其启用进程逗留。系统管理员可以使用相同的命令伴随着 <parameter>user</parameter> 参数，来帮某个用户实现。用户可以在之后使用命令 <command>systemd-run</command> 来启动长时间运行进程。举个例子：<command>systemd-run --scope
          --user /usr/bin/screen</command>。如果你为你的用户启用了逗留，user@.service 会在所有的登录会话被关闭后仍然保留，并在系统启动后自动启动。这样做的好处是明确地表明是否允许进程在用户会话结束后继续运行，但却打破了对于类似于 <command>nohup</command> 之类工具和使用 <function>deamon()</function> 的公用方法的向后兼容。</para>
      </listitem>
      <listitem>
        <para>
          <emphasis>启用系统范围的进程逗留</emphasis>：你可以在 <filename>/etc/logind.conf</filename> 中设置 <parameter>KillUserProcesses=no</parameter> 来全局地为每个用户启用进程逗留。这在牺牲明确控制的同时，带来了将旧方法提供给所有用户的好处。</para>
      </listitem>
      <listitem>
        <para>
          <emphasis>在构建时禁用</emphasis>：你可以通过在构建 systemd 时向命令 <command>configure</command> 添加 <parameter>--without-kill-user-processes</parameter>，以此来默认启用逗留。这会使 systemd 完全丧失在用户会话结束后杀死进程的能力。</para>
      </listitem>
    </itemizedlist>

  </sect2>

</sect1>
